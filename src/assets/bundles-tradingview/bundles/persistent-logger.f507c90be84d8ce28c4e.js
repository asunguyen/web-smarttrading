"use strict";(self.webpackChunktradingview=self.webpackChunktradingview||[]).push([[94882],{327629:(e,t,n)=>{n.r(t),n.d(t,{initPersistentLogger:()=>L});let r,s;const o=new WeakMap,i=new WeakMap,a=new WeakMap,c=new WeakMap,d=new WeakMap;let u={get(e,t,n){if(e instanceof IDBTransaction){if("done"===t)return i.get(e);if("objectStoreNames"===t)return e.objectStoreNames||a.get(e);if("store"===t)return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return f(e[t])},set:(e,t,n)=>(e[t]=n,!0),has:(e,t)=>e instanceof IDBTransaction&&("done"===t||"store"===t)||t in e};function l(e){return e!==IDBDatabase.prototype.transaction||"objectStoreNames"in IDBTransaction.prototype?(s||(s=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])).includes(e)?function(...t){return e.apply(g(this),t),f(o.get(this))}:function(...t){return f(e.apply(g(this),t))}:function(t,...n){const r=e.call(g(this),t,...n);return a.set(r,t.sort?t.sort():[t]),f(r)}}function p(e){return"function"==typeof e?l(e):(e instanceof IDBTransaction&&function(e){if(i.has(e))return;const t=new Promise(((t,n)=>{const r=()=>{e.removeEventListener("complete",s),e.removeEventListener("error",o),e.removeEventListener("abort",o)},s=()=>{t(),r()},o=()=>{n(e.error||new DOMException("AbortError","AbortError")),r()};e.addEventListener("complete",s),e.addEventListener("error",o),e.addEventListener("abort",o)}));i.set(e,t)}(e),t=e,(r||(r=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])).some((e=>t instanceof e))?new Proxy(e,u):e);var t}function f(e){if(e instanceof IDBRequest)return function(e){const t=new Promise(((t,n)=>{const r=()=>{e.removeEventListener("success",s),e.removeEventListener("error",o)},s=()=>{t(f(e.result)),r()},o=()=>{n(e.error),r()};e.addEventListener("success",s),e.addEventListener("error",o)}));return t.then((t=>{t instanceof IDBCursor&&o.set(t,e)})).catch((()=>{})),d.set(t,e),t}(e);if(c.has(e))return c.get(e);const t=p(e);return t!==e&&(c.set(e,t),d.set(t,e)),t}const g=e=>d.get(e);const m=["get","getKey","getAll","getAllKeys","count"],h=["put","add","delete","clear"],v=new Map;function w(e,t){if(!(e instanceof IDBDatabase)||t in e||"string"!=typeof t)return;if(v.get(t))return v.get(t);const n=t.replace(/FromIndex$/,""),r=t!==n,s=h.includes(n);if(!(n in(r?IDBIndex:IDBObjectStore).prototype)||!s&&!m.includes(n))return;const o=async function(e,...t){const o=this.transaction(e,s?"readwrite":"readonly");let i=o.store;return r&&(i=i.index(t.shift())),(await Promise.all([i[n](...t),s&&o.done]))[0]};return v.set(t,o),o}u=(e=>({...e,get:(t,n,r)=>w(t,n)||e.get(t,n,r),has:(t,n)=>!!w(t,n)||e.has(t,n)}))(u);var y=n(389137),I=n(268222),b=n(234271);async function D(){return function(e,t,{blocked:n,upgrade:r,blocking:s,terminated:o}={}){const i=indexedDB.open(e,t),a=f(i);return r&&i.addEventListener("upgradeneeded",(e=>{r(f(i.result),e.oldVersion,e.newVersion,f(i.transaction),e)})),n&&i.addEventListener("blocked",(e=>n(e.oldVersion,e.newVersion,e))),a.then((e=>{
o&&e.addEventListener("close",(()=>o())),s&&e.addEventListener("versionchange",(e=>s(e.oldVersion,e.newVersion,e)))})).catch((()=>{})),a}("Sessions Logs",1,{upgrade:e=>{e.createObjectStore("session",{autoIncrement:!0}).createIndex("startDate","startDate",{unique:!1});const t=e.createObjectStore("entry",{autoIncrement:!0});t.createIndex("date","date",{unique:!1}),t.createIndex("session","session",{unique:!1})}})}Error;class E{constructor(e){this._currentOperationPromise=async function(){const e=await D(),t=window.location.href,n=(new Date).toISOString(),r=await e.add("session",{startDate:n,url:t});return{db:e,sessionId:r}}(),e.forEach(this._addEntry.bind(this))}addPersistentLogEntry(e,t,n){const r=(new Date).toISOString();this._addEntry({date:r,level:t,message:e,category:n})}getLastSessions(e=5){const t=(0,I.createDeferredPromise)();return this._currentOperationPromise=this._currentOperationPromise.then((async n=>{const r=[];let s=await n.db.transaction("session").store.openKeyCursor(void 0,"prev");for(;s&&r.length<e;)r.push(s.key),s=await s.continue();const o=r.map((e=>n.db.get("session",e))),i=r.map((e=>n.db.getAllFromIndex("entry","session",e))),a=await Promise.all(o),c=(await Promise.all(i)).map((e=>e.map((e=>{const{session:t,...n}=e;return n})))),d=a.filter(y.notUndefined).map(((e,t)=>({...e,entries:c[t]})));return t.resolve(d),n})).catch((e=>(t.reject(e),e.state))),t.promise}_addEntry(e){this._currentOperationPromise=this._currentOperationPromise.then((async t=>(await async function(e,t){const n=await e.transaction("session").objectStore("session").count();if(n>t){let r=n-t,s=await e.transaction("session").store.openKeyCursor(void 0,"next");const o=[];for(;s&&r>0;)o.push(s.key),r--,s=await s.continue();return Promise.all(o.map((t=>e.delete("session",t)))).then((()=>{}))}}(t.db,10),await t.db.add("entry",{...e,session:t.sessionId}),t))).catch((e=>e.state))}}function L(){var e,t,n;const r=null!==(n=null===(t=null===(e=(0,b.getPersistentLogger)())||void 0===e?void 0:e.pendingEntries)||void 0===t?void 0:t.call(e))&&void 0!==n?n:[],s=new E(r);(0,b.setPersistentLogger)(s)}}}]);